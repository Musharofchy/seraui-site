{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "curved-text",
  "title": "Curved Text",
  "description": "A minimalistic curved text component designed with React and Tailwind CSS.",
  "author": "Reche Soares",
  "type": "registry:ui",
  "dependencies": [],
  "devDependencies": [],
  "registryDependencies": [],
  "cssVars": {
    "dark": {},
    "light": {}
  },
  "files": [
    {
      "path": "curved-text.tsx",
      "content": "import CanvasCurvedLoop from \"./curved-text\"\r\n\r\nexport default function CanvasCurvedLoopExample() {\r\n  return (\r\n    <div className=\"flex flex-col items-center w-full font-sans\">\r\n      <div className=\"w-full max-w-7xl px-4\">\r\n        <CanvasCurvedLoop\r\n          text=\"A helpful UI library for design engineers. Use cool animations and components with just a copy and paste. Free and open source\"\r\n          speed={1}\r\n          curveHeight={50}\r\n          fontSize={64}\r\n          height={200}\r\n          gap={0.5}\r\n          easing={0.05}\r\n          direction=\"left\"\r\n          interactive={true}\r\n          className=\"rounded-lg overflow-hidden text-black dark:text-white\"\r\n        />\r\n      </div>\r\n    </div>\r\n  );\r\n}\r\n",
      "type": "registry:ui"
    },
    {
      "path": "curved-text.tsx",
      "content": "\"use client\"\r\nimport React, {\r\n  useRef,\r\n  useEffect,\r\n  useState,\r\n  useMemo,\r\n  FC,\r\n  PointerEvent,\r\n  useCallback,\r\n  CSSProperties,\r\n} from \"react\";\r\n\r\ninterface CanvasCurvedLoopProps {\r\n  text?: string;\r\n  speed?: number;\r\n  className?: string;\r\n  curveHeight?: number;\r\n  direction?: \"left\" | \"right\";\r\n  interactive?: boolean;\r\n  fontSize?: number;\r\n  fontFamily?: string;\r\n  fontWeight?: CSSProperties[\"fontWeight\"];\r\n  height?: number;\r\n  gap?: number;\r\n  easing?: number;\r\n  onDirectionChange?: (direction: \"left\" | \"right\") => void;\r\n}\r\n\r\nconst CanvasCurvedLoop: FC<CanvasCurvedLoopProps> = ({\r\n  text = \"\",\r\n  speed = 1,\r\n  className = \"\",\r\n  curveHeight = 50,\r\n  direction = \"left\",\r\n  interactive = true,\r\n  fontSize = 48,\r\n  fontFamily = \"system-ui, -apple-system, sans-serif\",\r\n  fontWeight = \"bold\",\r\n  height = 200,\r\n  gap = 0.5,\r\n  easing = 0.05,\r\n  onDirectionChange,\r\n}) => {\r\n  const canvasRef = useRef<HTMLCanvasElement>(null);\r\n  const offsetRef = useRef(0);\r\n  const targetOffsetRef = useRef(0);\r\n  const isDraggingRef = useRef(false);\r\n  const lastPointerXRef = useRef(0);\r\n  const velocityRef = useRef(0);\r\n  const directionRef = useRef(direction);\r\n  const lastTimeRef = useRef(0);\r\n  \r\n  const [isReady, setIsReady] = useState(false);\r\n  const [dimensions, setDimensions] = useState({ width: 0, height: 0 });\r\n  const [textWidth, setTextWidth] = useState(0);\r\n\r\n  const processedText = useMemo(() => {\r\n    const trimmed = text.trim();\r\n    if (!trimmed) return \"\";\r\n    return trimmed + \" \".repeat(Math.ceil(fontSize * gap / 10));\r\n  }, [text, fontSize, gap]);\r\n\r\n  useEffect(() => {\r\n    const updateDimensions = () => {\r\n      if (!canvasRef.current?.parentElement) return;\r\n      \r\n      const rect = canvasRef.current.parentElement.getBoundingClientRect();\r\n      const dpr = window.devicePixelRatio || 1;\r\n      \r\n      setDimensions({\r\n        width: rect.width * dpr,\r\n        height: height * dpr,\r\n      });\r\n    };\r\n\r\n    updateDimensions();\r\n    \r\n    const resizeObserver = new ResizeObserver(updateDimensions);\r\n    if (canvasRef.current?.parentElement) {\r\n      resizeObserver.observe(canvasRef.current.parentElement);\r\n    }\r\n    \r\n    return () => resizeObserver.disconnect();\r\n  }, [height]);\r\n\r\n  useEffect(() => {\r\n    const measureText = async () => {\r\n      const canvas = canvasRef.current;\r\n      if (!canvas || !processedText) return;\r\n\r\n      const ctx = canvas.getContext(\"2d\", { alpha: true });\r\n      if (!ctx) return;\r\n\r\n      try {\r\n        await document.fonts.ready;\r\n      } catch (e: unknown) {\r\n          if (e instanceof Error) {\r\n        console.error(e.message);\r\n        }\r\n      }\r\n\r\n      ctx.font = `${fontWeight} ${fontSize}px ${fontFamily}`;\r\n      const metrics = ctx.measureText(processedText);\r\n      \r\n      setTextWidth(metrics.width);\r\n      setIsReady(true);\r\n    };\r\n\r\n    measureText();\r\n  }, [processedText, fontSize, fontFamily, fontWeight]);\r\n\r\n  const drawCurvedText = useCallback((ctx: CanvasRenderingContext2D, offset: number) => {\r\n    const { width, height: canvasHeight } = dimensions;\r\n    if (!width || !canvasHeight || !textWidth || !processedText || !canvasRef.current) return;\r\n\r\n    ctx.clearRect(0, 0, width, canvasHeight);\r\n\r\n    ctx.save();\r\n    ctx.font = `${fontWeight} ${fontSize}px ${fontFamily}`;\r\n    ctx.fillStyle = getComputedStyle(canvasRef.current).color;\r\n    ctx.textAlign = \"center\";\r\n    ctx.textBaseline = \"middle\";\r\n\r\n    const repeatCount = Math.ceil(width / textWidth) + 2;\r\n\r\n    let normalizedOffset = offset % textWidth;\r\n    if (normalizedOffset > 0) normalizedOffset -= textWidth;\r\n\r\n    for (let i = 0; i < repeatCount; i++) {\r\n      const baseX = normalizedOffset + (i * textWidth);\r\n      \r\n      let charX = baseX;\r\n      for (let j = 0; j < processedText.length; j++) {\r\n        const char = processedText[j];\r\n        const charMetrics = ctx.measureText(char);\r\n        const charWidth = charMetrics.width;\r\n        \r\n        if (charX + charWidth < 0 || charX > width) {\r\n          charX += charWidth;\r\n          continue;\r\n        }\r\n        \r\n        const normalizedX = charX / width;\r\n        const t = normalizedX;\r\n        const curveY = canvasHeight / 2 - curveHeight * Math.sin(t * Math.PI);\r\n        \r\n        const angleT = Math.max(0, Math.min(1, normalizedX));\r\n        const derivative = -curveHeight * Math.PI * Math.cos(angleT * Math.PI) / width;\r\n        const angle = Math.atan(derivative);\r\n\r\n        ctx.save();\r\n        ctx.translate(charX + charWidth / 2, curveY);\r\n        ctx.rotate(angle);\r\n        ctx.fillText(char, 0, 0);\r\n        ctx.restore();\r\n\r\n        charX += charWidth;\r\n      }\r\n    }\r\n\r\n    ctx.restore();\r\n  }, [dimensions, textWidth, processedText, fontSize, fontFamily, fontWeight, curveHeight]);\r\n\r\n  useEffect(() => {\r\n    if (!isReady || !canvasRef.current || !dimensions.width || !textWidth) return;\r\n\r\n    const ctx = canvasRef.current.getContext(\"2d\", { alpha: true });\r\n    if (!ctx) return;\r\n\r\n    let animationFrameId: number;\r\n\r\n    const animate = (currentTime: number) => {\r\n      const deltaTime = currentTime - lastTimeRef.current;\r\n      lastTimeRef.current = currentTime;\r\n\r\n      if (!isDraggingRef.current) {\r\n        if (Math.abs(velocityRef.current) > 0.1) {\r\n          targetOffsetRef.current += velocityRef.current;\r\n          velocityRef.current *= 0.95; \r\n        } else {\r\n          const speedMultiplier = deltaTime > 0 ? deltaTime / 16.67 : 1;\r\n          const delta = directionRef.current === \"right\" ? speed : -speed;\r\n          targetOffsetRef.current += delta * speedMultiplier;\r\n        }\r\n      }\r\n\r\n      offsetRef.current += (targetOffsetRef.current - offsetRef.current) * easing;\r\n\r\n      if (offsetRef.current > textWidth) {\r\n        offsetRef.current -= textWidth;\r\n        targetOffsetRef.current -= textWidth;\r\n      } else if (offsetRef.current < -textWidth) {\r\n        offsetRef.current += textWidth;\r\n        targetOffsetRef.current += textWidth;\r\n      }\r\n\r\n      drawCurvedText(ctx, offsetRef.current);\r\n      animationFrameId = requestAnimationFrame(animate);\r\n    };\r\n\r\n    lastTimeRef.current = performance.now();\r\n    animationFrameId = requestAnimationFrame(animate);\r\n\r\n    return () => {\r\n      cancelAnimationFrame(animationFrameId);\r\n    };\r\n  }, [isReady, drawCurvedText, speed, textWidth, easing, dimensions.width]);\r\n\r\n  const handlePointerDown = useCallback((e: PointerEvent<HTMLCanvasElement>) => {\r\n    if (!interactive) return;\r\n    \r\n    isDraggingRef.current = true;\r\n    lastPointerXRef.current = e.clientX;\r\n    velocityRef.current = 0;\r\n    (e.currentTarget as HTMLCanvasElement).setPointerCapture(e.pointerId);\r\n    e.preventDefault();\r\n  }, [interactive]);\r\n\r\n  const handlePointerMove = useCallback((e: PointerEvent<HTMLCanvasElement>) => {\r\n    if (!interactive || !isDraggingRef.current) return;\r\n    \r\n    const dx = e.clientX - lastPointerXRef.current;\r\n    lastPointerXRef.current = e.clientX;\r\n    velocityRef.current = dx * 0.5;\r\n    targetOffsetRef.current += dx;\r\n    offsetRef.current += dx;\r\n  }, [interactive]);\r\n\r\n  const handlePointerUp = useCallback((e: PointerEvent<HTMLCanvasElement>) => {\r\n    if (!interactive) return;\r\n    \r\n    isDraggingRef.current = false;\r\n    \r\n    if (Math.abs(velocityRef.current) > 1) {\r\n      const newDirection = velocityRef.current > 0 ? \"right\" : \"left\";\r\n      if (newDirection !== directionRef.current) {\r\n        directionRef.current = newDirection;\r\n        onDirectionChange?.(newDirection);\r\n      }\r\n    }\r\n    \r\n    (e.currentTarget as HTMLCanvasElement).releasePointerCapture(e.pointerId);\r\n  }, [interactive, onDirectionChange]);\r\n\r\n  const cursorStyle = interactive\r\n    ? isDraggingRef.current ? \"grabbing\" : \"grab\"\r\n    : \"default\";\r\n\r\n  const canvasStyle: CSSProperties = {\r\n    height: `${height}px`,\r\n    cursor: cursorStyle,\r\n    touchAction: \"none\",\r\n    imageRendering: \"crisp-edges\",\r\n  };\r\n\r\n  return (\r\n    <div className={`relative w-full ${className}`}>\r\n      <canvas\r\n        ref={canvasRef}\r\n        width={dimensions.width}\r\n        height={dimensions.height}\r\n        className=\"w-full block\"\r\n        style={canvasStyle}\r\n        onPointerDown={handlePointerDown}\r\n        onPointerMove={handlePointerMove}\r\n        onPointerUp={handlePointerUp}\r\n        onPointerLeave={handlePointerUp}\r\n        onPointerCancel={handlePointerUp}\r\n      />\r\n      {!isReady && (\r\n        <div className=\"absolute inset-0 flex items-center justify-center\">\r\n          <div className=\"text-white/50\">Loading...</div>\r\n        </div>\r\n      )}\r\n    </div>\r\n  );\r\n};\r\n\r\nCanvasCurvedLoop.displayName = \"CanvasCurvedLoop\";\r\nexport default CanvasCurvedLoop;",
      "type": "registry:ui"
    }
  ]
}