{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "infinite-grid",
  "title": "Infinite Grid",
  "description": "A minimalistic infinite grid component designed with React and Tailwind CSS.",
  "author": "Reche Soares",
  "type": "registry:ui",
  "dependencies": [],
  "devDependencies": [],
  "registryDependencies": [],
  "cssVars": {
    "dark": {},
    "light": {}
  },
  "files": [
    {
      "path": "infinite-grid.tsx",
      "content": "\"use client\";\r\nimport React, {\r\n  useState,\r\n  useEffect,\r\n  useRef,\r\n  useCallback,\r\n  useMemo\r\n} from 'react';\r\n\r\n// --- Constants ---\r\nconst CARD_WIDTH = 256;\r\nconst CARD_HEIGHT = 171;\r\nconst GALLERY_JSON_URL =\r\n  'https://s3-us-west-2.amazonaws.com/s.cdpn.io/204379/gallery.json';\r\n\r\nconst NEIGHBOURS: [number, number][] = [\r\n  [0, -1], [0, 1], [1, 0], [-1, 0],\r\n  [1, 1], [-1, 1], [-1, -1], [1, -1]\r\n];\r\n\r\n// --- Types ---\r\ninterface GalleryItem {\r\n  id?: number;\r\n  thumb_src: string;\r\n  title?: string;\r\n  full_src?: string;\r\n}\r\n\r\ninterface Offset {\r\n  x: number;\r\n  y: number;\r\n}\r\n\r\ninterface CardProps {\r\n  descriptor: GalleryItem;\r\n  x: number;\r\n  y: number;\r\n}\r\n\r\ninterface InfiniteDraggableGridProps {\r\n  gallery: GalleryItem[];\r\n}\r\n\r\n// --- Helper Functions ---\r\nconst clamp = (value: number, min: number, max: number) =>\r\n  Math.min(Math.max(value, min), max);\r\n\r\nconst applyDamping = (velocity: number, deltaTime: number) => {\r\n  const dampingRate = 0.0028;\r\n  return velocity * Math.exp(-dampingRate * deltaTime);\r\n};\r\n\r\nconst smoothStep = (\r\n  current: number,\r\n  target: number,\r\n  deltaTime: number,\r\n  speed = 0.15\r\n) => current + (target - current) * (1 - Math.exp(-speed * deltaTime));\r\n\r\n// --- Hooks ---\r\nconst useViewportSize = () => {\r\n  const [size, setSize] = useState({ width: 0, height: 0 });\r\n  useEffect(() => {\r\n    const handleResize = () => {\r\n      setSize({ width: window.innerWidth, height: window.innerHeight });\r\n    };\r\n    window.addEventListener('resize', handleResize);\r\n    handleResize();\r\n    return () => window.removeEventListener('resize', handleResize);\r\n  }, []);\r\n  return size;\r\n};\r\n\r\nconst useAnimationFrame = (callback: (deltaTime: number) => void) => {\r\n  const requestRef = useRef<number | null>(null);\r\n  const previousTimeRef = useRef<number | undefined>(undefined);\r\n\r\n  const animate = useCallback(\r\n    (time: number) => {\r\n      if (previousTimeRef.current !== undefined) {\r\n        const deltaTime = time - previousTimeRef.current;\r\n        callback(deltaTime);\r\n      }\r\n      previousTimeRef.current = time;\r\n      requestRef.current = requestAnimationFrame(animate);\r\n    },\r\n    [callback]\r\n  );\r\n\r\n  useEffect(() => {\r\n    requestRef.current = requestAnimationFrame(animate);\r\n    return () => {\r\n      if (requestRef.current !== null) cancelAnimationFrame(requestRef.current);\r\n    };\r\n  }, [animate]);\r\n};\r\n\r\n// --- Components ---\r\nconst Card = React.memo<CardProps>(({ descriptor, x, y }) => {\r\n  const [opacity, setOpacity] = useState(0);\r\n  const imgRef = useRef<HTMLImageElement | null>(null);\r\n\r\n  useEffect(() => {\r\n    setOpacity(0);\r\n    const img = new Image();\r\n    img.src = descriptor.thumb_src;\r\n    const fadeIn = () => {\r\n      let start: number | null = null;\r\n      const fade = (t: number) => {\r\n        if (start === null) start = t;\r\n        const p = Math.min(1, (t - start) / 300);\r\n        setOpacity(p);\r\n        if (p < 1) requestAnimationFrame(fade);\r\n      };\r\n      requestAnimationFrame(fade);\r\n    };\r\n\r\n    if (img.decode) {\r\n      img.decode().then(fadeIn).catch(fadeIn);\r\n    } else {\r\n      img.onload = fadeIn;\r\n    }\r\n  }, [descriptor]);\r\n\r\n  return (\r\n    <div\r\n      className=\"absolute overflow-hidden\"\r\n      style={{\r\n        transform: `translate3d(${x}px, ${y}px, 0)`,\r\n        willChange: 'transform',\r\n        width: CARD_WIDTH,\r\n        height: CARD_HEIGHT,\r\n        maxWidth: CARD_WIDTH,\r\n        maxHeight: CARD_HEIGHT,\r\n        contain: 'layout style paint',\r\n      }}\r\n    >\r\n      <img\r\n        ref={imgRef}\r\n        src={descriptor.thumb_src}\r\n        alt={descriptor.title || 'Gallery image'}\r\n        className=\"absolute top-0 left-0 w-full h-full object-cover pointer-events-none select-none\"\r\n        style={{\r\n          opacity,\r\n          transition: 'opacity 0.3s ease-out',\r\n          imageRendering: 'crisp-edges',\r\n          backfaceVisibility: 'hidden',\r\n          transform: 'translateZ(0)',\r\n        }}\r\n        loading=\"lazy\"\r\n        decoding=\"async\"\r\n      />\r\n    </div>\r\n  );\r\n}, (prevProps, nextProps) =>\r\n  prevProps.descriptor === nextProps.descriptor &&\r\n  prevProps.x === nextProps.x &&\r\n  prevProps.y === nextProps.y\r\n);\r\n\r\nCard.displayName = 'Card';\r\n\r\nconst InfiniteDraggableGrid: React.FC<InfiniteDraggableGridProps> = ({ gallery }) => {\r\n  const viewportSize = useViewportSize();\r\n  const [offset, setOffset] = useState<Offset>({ x: 0, y: 0 });\r\n  const [targetOffset, setTargetOffset] = useState<Offset>({ x: 0, y: 0 });\r\n  const [isFullscreen, setIsFullscreen] = useState(false);\r\n  const [visibleCards, setVisibleCards] = useState<\r\n    { key: string; descriptor: GalleryItem; x: number; y: number }[]\r\n  >([]);\r\n  const [velocity, setVelocity] = useState<Offset>({ x: 0, y: 0 });\r\n\r\n  const isDraggingRef = useRef(false);\r\n  const lastPositionRef = useRef<Offset>({ x: 0, y: 0 });\r\n  const lastTimeRef = useRef<number>(Date.now());\r\n  const picksRef = useRef<Record<string, GalleryItem>>({});\r\n  const containerRef = useRef<HTMLDivElement | null>(null);\r\n  const momentumRef = useRef<Offset>({ x: 0, y: 0 });\r\n\r\n  // Detect if we're in fullscreen mode by checking parent container\r\n  useEffect(() => {\r\n    const checkFullscreen = () => {\r\n      if (containerRef.current) {\r\n        const parent = containerRef.current.parentElement;\r\n        const isInFullscreenContainer = parent?.classList.contains('fixed') &&\r\n                                       parent?.classList.contains('inset-0');\r\n        setIsFullscreen(isInFullscreenContainer || false);\r\n      }\r\n    };\r\n\r\n    checkFullscreen();\r\n    const observer = new MutationObserver(checkFullscreen);\r\n    if (containerRef.current?.parentElement) {\r\n      observer.observe(containerRef.current.parentElement, {\r\n        attributes: true,\r\n        attributeFilter: ['class']\r\n      });\r\n    }\r\n\r\n    return () => observer.disconnect();\r\n  }, []);\r\n\r\n  useAnimationFrame(\r\n    useCallback(\r\n      (deltaTime) => {\r\n        if (!isDraggingRef.current) {\r\n          momentumRef.current.x = applyDamping(momentumRef.current.x, deltaTime);\r\n          momentumRef.current.y = applyDamping(momentumRef.current.y, deltaTime);\r\n\r\n          if (Math.abs(momentumRef.current.x) < 0.01) momentumRef.current.x = 0;\r\n          if (Math.abs(momentumRef.current.y) < 0.01) momentumRef.current.y = 0;\r\n\r\n          setTargetOffset((prev) => ({\r\n            x: prev.x + momentumRef.current.x,\r\n            y: prev.y + momentumRef.current.y\r\n          }));\r\n        }\r\n        setOffset((prev) => ({\r\n          x: smoothStep(prev.x, targetOffset.x, deltaTime, isDraggingRef.current ? 0.4 : 0.18),\r\n          y: smoothStep(prev.y, targetOffset.y, deltaTime, isDraggingRef.current ? 0.4 : 0.18)\r\n        }));\r\n      },\r\n      [targetOffset]\r\n    )\r\n  );\r\n\r\n  const handleDragStart = useCallback((e: React.MouseEvent | React.TouchEvent) => {\r\n    isDraggingRef.current = true;\r\n    momentumRef.current = { x: 0, y: 0 };\r\n    const point = 'touches' in e ? e.touches[0] : e;\r\n    lastPositionRef.current = { x: point.clientX, y: point.clientY };\r\n    lastTimeRef.current = Date.now();\r\n    if (containerRef.current) containerRef.current.style.cursor = 'grabbing';\r\n  }, []);\r\n\r\n  const handleDragMove = useCallback((e: MouseEvent | TouchEvent) => {\r\n    if (!isDraggingRef.current) return;\r\n    e.preventDefault();\r\n    const point = (e instanceof TouchEvent) ? e.touches[0] : e;\r\n    const currentTime = Date.now();\r\n    const timeDelta = currentTime - lastTimeRef.current;\r\n\r\n    const deltaX = point.clientX - lastPositionRef.current.x;\r\n    const deltaY = point.clientY - lastPositionRef.current.y;\r\n\r\n    if (timeDelta > 0) {\r\n      const vx = (deltaX / timeDelta) * 16;\r\n      const vy = (deltaY / timeDelta) * 16;\r\n      setVelocity((prev) => ({\r\n        x: prev.x * 0.5 + vx * 0.5,\r\n        y: prev.y * 0.5 + vy * 0.5\r\n      }));\r\n    }\r\n    lastPositionRef.current = { x: point.clientX, y: point.clientY };\r\n    lastTimeRef.current = currentTime;\r\n\r\n    setTargetOffset((prev) => ({\r\n      x: prev.x + deltaX,\r\n      y: prev.y + deltaY\r\n    }));\r\n  }, []);\r\n\r\n  const handleDragEnd = useCallback(() => {\r\n    if (!isDraggingRef.current) return;\r\n    isDraggingRef.current = false;\r\n    momentumRef.current = {\r\n      x: clamp(velocity.x, -30, 30),\r\n      y: clamp(velocity.y, -30, 30)\r\n    };\r\n    setVelocity({ x: 0, y: 0 });\r\n    if (containerRef.current) containerRef.current.style.cursor = 'grab';\r\n  }, [velocity]);\r\n\r\n  useEffect(() => {\r\n    const move = (e: MouseEvent | TouchEvent) => handleDragMove(e);\r\n    const end = () => handleDragEnd();\r\n\r\n    window.addEventListener('mousemove', move);\r\n    window.addEventListener('touchmove', move, { passive: false });\r\n    window.addEventListener('mouseup', end);\r\n    window.addEventListener('touchend', end);\r\n\r\n    return () => {\r\n      window.removeEventListener('mousemove', move);\r\n      window.removeEventListener('touchmove', move);\r\n      window.removeEventListener('mouseup', end);\r\n      window.removeEventListener('touchend', end);\r\n    };\r\n  }, [handleDragMove, handleDragEnd]);\r\n\r\n  const visibleCardsData = useMemo(() => {\r\n    if (!gallery.length || viewportSize.width === 0) return [];\r\n    const getGalleryDescriptor = (index: number) =>\r\n      gallery[Math.abs(index % gallery.length)];\r\n    const getRandomSafe = (col: number, row: number): GalleryItem => {\r\n      let pick: GalleryItem | undefined;\r\n      let tries = 0;\r\n      while (pick === undefined) {\r\n        const rnd = Math.floor(Math.random() * gallery.length);\r\n        const item = getGalleryDescriptor(rnd);\r\n        let isSafe = true;\r\n        for (const offsets of NEIGHBOURS) {\r\n          const key = `${col + offsets[0]}:${row + offsets[1]}`;\r\n          if (picksRef.current[key] === item) {\r\n            isSafe = false;\r\n            break;\r\n          }\r\n        }\r\n        if (tries++ > 20 || isSafe) {\r\n          pick = item;\r\n        }\r\n      }\r\n      return pick;\r\n    };\r\n    const getRandomDescriptor = (col: number, row: number) => {\r\n      const key = `${col}:${row}`;\r\n      if (!picksRef.current[key]) {\r\n        picksRef.current[key] = getRandomSafe(col, row);\r\n      }\r\n      return picksRef.current[key];\r\n    };\r\n    const getCardPos = (col: number, row: number) => {\r\n      const x = col * CARD_WIDTH + (Math.round(offset.x) % CARD_WIDTH) - CARD_WIDTH;\r\n      const y = row * CARD_HEIGHT + (Math.round(offset.y) % CARD_HEIGHT) - CARD_HEIGHT;\r\n      return [x, y] as const;\r\n    };\r\n    const isVisible = (x: number, y: number) => {\r\n      const buffer = 100;\r\n      return (\r\n        x + CARD_WIDTH > -buffer &&\r\n        y + CARD_HEIGHT > -buffer &&\r\n        x < viewportSize.width + buffer &&\r\n        y < viewportSize.height + buffer\r\n      );\r\n    };\r\n    const viewCols = Math.ceil(viewportSize.width / CARD_WIDTH) + 4;\r\n    const viewRows = Math.ceil(viewportSize.height / CARD_HEIGHT) + 4;\r\n    const colOffset = Math.floor(offset.x / CARD_WIDTH) * -1;\r\n    const rowOffset = Math.floor(offset.y / CARD_HEIGHT) * -1;\r\n\r\n    const newVisibleCards: {\r\n      key: string; descriptor: GalleryItem; x: number; y: number;\r\n    }[] = [];\r\n\r\n    for (let row = -2; row < viewRows; row++) {\r\n      for (let col = -2; col < viewCols; col++) {\r\n        const tCol = colOffset + col;\r\n        const tRow = rowOffset + row;\r\n        const desc = getRandomDescriptor(tCol, tRow);\r\n        const [x, y] = getCardPos(col, row);\r\n        if (isVisible(x, y)) {\r\n          newVisibleCards.push({\r\n            key: `${tCol}:${tRow}`,\r\n            descriptor: desc,\r\n            x, y\r\n          });\r\n        }\r\n      }\r\n    }\r\n    return newVisibleCards;\r\n  }, [gallery, offset, viewportSize]);\r\n\r\n  useEffect(() => {\r\n    setVisibleCards(visibleCardsData);\r\n  }, [visibleCardsData]);\r\n\r\n  return (\r\n    <div\r\n      ref={containerRef}\r\n      className={`w-full h-full select-none cursor-grab overflow-hidden ${\r\n        isFullscreen ? 'fixed inset-0' : 'relative'\r\n      }`}\r\n      onMouseDown={handleDragStart}\r\n      onTouchStart={handleDragStart}\r\n      style={{\r\n        background: 'radial-gradient(ellipse at center, #1a1a1a 0%, #000000 100%)',\r\n        touchAction: 'none',\r\n        minHeight: isFullscreen ? '100vh' : '400px',\r\n        height: isFullscreen ? '100vh' : '100%',\r\n        width: isFullscreen ? '100vw' : '100%',\r\n        margin: 0,\r\n        padding: 0,\r\n      }}\r\n    >\r\n      <div\r\n        className=\"absolute inset-0 overflow-hidden\"\r\n        style={{\r\n          transform: 'translateZ(0)',\r\n          backfaceVisibility: 'hidden',\r\n          width: '100%',\r\n          height: '100%',\r\n        }}\r\n      >\r\n        {visibleCards.map((card) => (\r\n          <Card key={card.key} descriptor={card.descriptor} x={card.x} y={card.y} />\r\n        ))}\r\n      </div>\r\n\r\n      {/* Centered \"drag me\" text */}\r\n      <div className=\"absolute inset-0 flex items-center justify-center pointer-events-none z-10\">\r\n        <h1 className=\"text-white text-6xl font-bold tracking-wider opacity-80 select-none drop-shadow-2xl\">\r\n          drag me\r\n        </h1>\r\n      </div>\r\n    </div>\r\n  );\r\n};\r\n\r\n// --- Main App ---\r\n// Fallback data with real gallery images\r\nconst FALLBACK_GALLERY: GalleryItem[] = [\r\n  { id: 0, full_src: \"https://s3-us-west-2.amazonaws.com/s.cdpn.io/204379/0.jpg\", thumb_src: \"https://s3-us-west-2.amazonaws.com/s.cdpn.io/204379/thumb_0.jpg\", title: \"Gallery Image 0\" },\r\n  { id: 1, full_src: \"https://s3-us-west-2.amazonaws.com/s.cdpn.io/204379/1.jpg\", thumb_src: \"https://s3-us-west-2.amazonaws.com/s.cdpn.io/204379/thumb_1.jpg\", title: \"Gallery Image 1\" },\r\n  { id: 2, full_src: \"https://s3-us-west-2.amazonaws.com/s.cdpn.io/204379/2.jpg\", thumb_src: \"https://s3-us-west-2.amazonaws.com/s.cdpn.io/204379/thumb_2.jpg\", title: \"Gallery Image 2\" },\r\n  { id: 3, full_src: \"https://s3-us-west-2.amazonaws.com/s.cdpn.io/204379/3.jpg\", thumb_src: \"https://s3-us-west-2.amazonaws.com/s.cdpn.io/204379/thumb_3.jpg\", title: \"Gallery Image 3\" },\r\n  { id: 4, full_src: \"https://s3-us-west-2.amazonaws.com/s.cdpn.io/204379/4.jpg\", thumb_src: \"https://s3-us-west-2.amazonaws.com/s.cdpn.io/204379/thumb_4.jpg\", title: \"Gallery Image 4\" },\r\n  { id: 5, full_src: \"https://s3-us-west-2.amazonaws.com/s.cdpn.io/204379/5.jpg\", thumb_src: \"https://s3-us-west-2.amazonaws.com/s.cdpn.io/204379/thumb_5.jpg\", title: \"Gallery Image 5\" },\r\n  { id: 6, full_src: \"https://s3-us-west-2.amazonaws.com/s.cdpn.io/204379/6.jpg\", thumb_src: \"https://s3-us-west-2.amazonaws.com/s.cdpn.io/204379/thumb_6.jpg\", title: \"Gallery Image 6\" },\r\n  { id: 7, full_src: \"https://s3-us-west-2.amazonaws.com/s.cdpn.io/204379/7.jpg\", thumb_src: \"https://s3-us-west-2.amazonaws.com/s.cdpn.io/204379/thumb_7.jpg\", title: \"Gallery Image 7\" },\r\n  { id: 8, full_src: \"https://s3-us-west-2.amazonaws.com/s.cdpn.io/204379/8.jpg\", thumb_src: \"https://s3-us-west-2.amazonaws.com/s.cdpn.io/204379/thumb_8.jpg\", title: \"Gallery Image 8\" },\r\n  { id: 9, full_src: \"https://s3-us-west-2.amazonaws.com/s.cdpn.io/204379/9.jpg\", thumb_src: \"https://s3-us-west-2.amazonaws.com/s.cdpn.io/204379/thumb_9.jpg\", title: \"Gallery Image 9\" },\r\n  { id: 10, full_src: \"https://s3-us-west-2.amazonaws.com/s.cdpn.io/204379/10.jpg\", thumb_src: \"https://s3-us-west-2.amazonaws.com/s.cdpn.io/204379/thumb_10.jpg\", title: \"Gallery Image 10\" },\r\n  { id: 11, full_src: \"https://s3-us-west-2.amazonaws.com/s.cdpn.io/204379/11.jpg\", thumb_src: \"https://s3-us-west-2.amazonaws.com/s.cdpn.io/204379/thumb_11.jpg\", title: \"Gallery Image 11\" },\r\n  { id: 12, full_src: \"https://s3-us-west-2.amazonaws.com/s.cdpn.io/204379/12.jpg\", thumb_src: \"https://s3-us-west-2.amazonaws.com/s.cdpn.io/204379/thumb_12.jpg\", title: \"Gallery Image 12\" },\r\n  { id: 13, full_src: \"https://s3-us-west-2.amazonaws.com/s.cdpn.io/204379/13.jpg\", thumb_src: \"https://s3-us-west-2.amazonaws.com/s.cdpn.io/204379/thumb_13.jpg\", title: \"Gallery Image 13\" },\r\n  { id: 14, full_src: \"https://s3-us-west-2.amazonaws.com/s.cdpn.io/204379/14.jpg\", thumb_src: \"https://s3-us-west-2.amazonaws.com/s.cdpn.io/204379/thumb_14.jpg\", title: \"Gallery Image 14\" },\r\n  { id: 15, full_src: \"https://s3-us-west-2.amazonaws.com/s.cdpn.io/204379/15.jpg\", thumb_src: \"https://s3-us-west-2.amazonaws.com/s.cdpn.io/204379/thumb_15.jpg\", title: \"Gallery Image 15\" },\r\n  { id: 16, full_src: \"https://s3-us-west-2.amazonaws.com/s.cdpn.io/204379/16.jpg\", thumb_src: \"https://s3-us-west-2.amazonaws.com/s.cdpn.io/204379/thumb_16.jpg\", title: \"Gallery Image 16\" },\r\n  { id: 17, full_src: \"https://s3-us-west-2.amazonaws.com/s.cdpn.io/204379/17.jpg\", thumb_src: \"https://s3-us-west-2.amazonaws.com/s.cdpn.io/204379/thumb_17.jpg\", title: \"Gallery Image 17\" },\r\n  { id: 18, full_src: \"https://s3-us-west-2.amazonaws.com/s.cdpn.io/204379/18.jpg\", thumb_src: \"https://s3-us-west-2.amazonaws.com/s.cdpn.io/204379/thumb_18.jpg\", title: \"Gallery Image 18\" },\r\n  { id: 19, full_src: \"https://s3-us-west-2.amazonaws.com/s.cdpn.io/204379/19.jpg\", thumb_src: \"https://s3-us-west-2.amazonaws.com/s.cdpn.io/204379/thumb_19.jpg\", title: \"Gallery Image 19\" },\r\n];\r\n\r\nexport default function Infinitegrid() {\r\n  const [galleryData, setGalleryData] = useState<GalleryItem[]>(FALLBACK_GALLERY);\r\n  const [isLoading, setIsLoading] = useState(false);\r\n\r\n  useEffect(() => {\r\n    const fetchData = async () => {\r\n      try {\r\n        setIsLoading(true);\r\n        const response = await fetch(GALLERY_JSON_URL);\r\n        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);\r\n        const data: { images: GalleryItem[] } = await response.json();\r\n        if (data.images && data.images.length > 0) {\r\n          // Add titles to images that don't have them\r\n          const imagesWithTitles = data.images.map((img, index) => ({\r\n            ...img,\r\n            title: img.title || `Gallery Image ${img.id ?? index}`\r\n          }));\r\n          setGalleryData(imagesWithTitles);\r\n        }\r\n      } catch (e) {\r\n        console.warn('Failed to fetch gallery data, using fallback:', e);\r\n        // Keep using fallback data instead of showing error\r\n      } finally {\r\n        setIsLoading(false);\r\n      }\r\n    };\r\n    fetchData();\r\n  }, []);\r\n\r\n  if (isLoading && galleryData.length === 0) {\r\n    return (\r\n      <div className=\"w-full h-full bg-black flex items-center justify-center text-white font-sans min-h-[400px]\">\r\n        <div className=\"text-center\">\r\n          <div className=\"inline-block animate-spin rounded-full h-8 w-8 border-b-2 border-white mb-2\"></div>\r\n          <div className=\"text-sm\">Loading gallery...</div>\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n\r\n  return (\r\n    <div className=\"w-full h-full bg-black overflow-hidden m-0 min-h-[400px]\">\r\n      <InfiniteDraggableGrid gallery={galleryData} />\r\n      {isLoading && (\r\n        <div className=\"absolute top-2 right-2 text-white text-xs opacity-50\">\r\n          Updating...\r\n        </div>\r\n      )}\r\n    </div>\r\n  );\r\n}",
      "type": "registry:ui"
    }
  ]
}